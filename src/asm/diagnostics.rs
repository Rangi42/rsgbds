use std::{cell::Cell, ops::Range};

use ariadne::{Config, IndexType, Label, ReportKind};
use yansi::Color;

use crate::{
    context_stack::{SourceNode, Span},
    source_store::{RawSpan, Report, ReportBuilder, SourceHandle, SourceStore},
    Options,
};

const ERROR_COLOR: Color = Color::Red;
pub const ERROR_KIND: ReportKind = ReportKind::Custom("error", ERROR_COLOR);

const WARNING_COLOR: Color = Color::Yellow;
pub const WARNING_KIND: ReportKind = ReportKind::Custom("warning", WARNING_COLOR);

const NOTE_COLOR: Color = Color::Fixed(115); // ariadne's default `note_color`.

pub fn error<F: FnOnce(&mut ReportBuilder)>(
    span: &Span<'_>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if nb_errors_left.get() == 0 {
        return;
    }

    let mut error = Report::build(ERROR_KIND, span.resolve())
        .with_config(Config::default().with_index_type(IndexType::Byte));
    build(&mut error);
    error
        .finish()
        .eprint(sources)
        .expect("Failed to print diagnostic");
    decrement_error_count(sources, nb_errors_left, options);
}

pub fn lex_error<F: FnOnce(ReportBuilder, RawSpan) -> ReportBuilder>(
    src_node: &SourceNode,
    byte_range: &Range<usize>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if nb_errors_left.get() == 0 {
        return;
    }

    let span = src_node.resolve(byte_range);
    build(
        Report::build(ERROR_KIND, span.clone())
            .with_config(Config::default().with_index_type(IndexType::Byte)),
        span,
    )
    .finish()
    .eprint(sources)
    .expect("Failed to print diagnostic");
    decrement_error_count(sources, nb_errors_left, options);
}

fn decrement_error_count(sources: &SourceStore, nb_errors_left: &Cell<usize>, options: &Options) {
    nb_errors_left.set(nb_errors_left.get() - 1);

    if nb_errors_left.get() == 0 {
        let span = Span::BUILTIN.resolve();
        Report::build(WARNING_KIND, span)
            .with_message(format!(
                "Reached {} errors, any subsequent will not be printed",
                options.max_errors,
            ))
            .finish()
            .eprint(sources)
            .expect("Failed to print diagnostic");
    }
}

pub fn warn<F: FnOnce(&mut ReportBuilder)>(
    id: WarningKind,
    span: &Span<'_>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if options.inhibit_warnings {
        return;
    }

    let kind = match options.warnings[id.0] {
        WarningLevel::Error => ERROR_KIND,
        WarningLevel::Enabled => WARNING_KIND,
        WarningLevel::Default if DEFAULT_WARNINGS[id.0] => WARNING_KIND,
        WarningLevel::Default => return,
        WarningLevel::Disabled => return,
    };
    if kind == ERROR_KIND && nb_errors_left.get() == 0 {
        return;
    }

    let span = span.resolve();
    let mut warning = Report::build(kind, span)
        .with_config(Config::default().with_index_type(IndexType::Byte))
        .with_code(id);
    build(&mut warning);
    warning
        .finish()
        .eprint(sources)
        .expect("Failed to print diagnostic");
    if kind == ERROR_KIND {
        decrement_error_count(sources, nb_errors_left, options);
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WarningLevel {
    Disabled,
    Enabled,
    Error,
    Default, // "Meta" warnings will only override this level.
}

// This file is generated by the build script (`build.rs`).
include!(concat!(env!("OUT_DIR"), "/warnings.rs"));

pub fn error_label<S: Into<RawSpan>>(span: S) -> Label<RawSpan> {
    Label::new(span.into()).with_color(ERROR_COLOR)
}

pub fn warning_label<S: Into<RawSpan>>(span: S) -> Label<RawSpan> {
    Label::new(span.into()).with_color(WARNING_COLOR)
}

pub fn note_label<S: Into<RawSpan>>(span: S) -> Label<RawSpan> {
    Label::new(span.into()).with_color(NOTE_COLOR)
}
