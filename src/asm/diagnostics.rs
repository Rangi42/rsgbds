use std::{cell::Cell, ops::Range};

use ariadne::{Config, IndexType, Label, ReportKind};
use yansi::Color;

use crate::{
    context_stack::{SourceNode, Span},
    source_store::{RawSpan, Report, ReportBuilder, SourceHandle, SourceStore},
    Options,
};

const ERROR_COLOR: Color = Color::Red;
pub const ERROR_KIND: ReportKind = ReportKind::Custom("error", ERROR_COLOR);

pub fn error<F: FnOnce(ReportBuilder) -> ReportBuilder>(
    span: Span<'_>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if nb_errors_left.get() == 0 {
        return;
    }

    let (src_id, byte_range) = span.resolve();
    build(
        Report::build(ERROR_KIND, src_id, byte_range.start)
            .with_config(Config::new().with_index_type(IndexType::Byte)),
    )
    .finish()
    .eprint(sources)
    .expect("Failed to print diagnostic");
    decrement_error_count(sources, nb_errors_left, options);
}

pub fn lex_error<F: FnOnce(ReportBuilder, (SourceHandle, Range<usize>)) -> ReportBuilder>(
    src_node: &SourceNode,
    byte_range: &Range<usize>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if nb_errors_left.get() == 0 {
        return;
    }

    let (src_id, byte_range) = src_node.resolve(byte_range);
    build(
        Report::build(ERROR_KIND, src_id, byte_range.start)
            .with_config(Config::new().with_index_type(IndexType::Byte)),
        (src_id, byte_range),
    )
    .finish()
    .eprint(sources)
    .expect("Failed to print diagnostic");
    decrement_error_count(sources, nb_errors_left, options);
}

fn decrement_error_count(sources: &SourceStore, nb_errors_left: &Cell<usize>, options: &Options) {
    nb_errors_left.set(nb_errors_left.get() - 1);

    if nb_errors_left.get() == 0 {
        let (src_id, byte_range) = Span::BUILTIN.resolve();
        Report::build(WARNING_KIND, src_id, byte_range.start)
            .with_message(format!(
                "Reached {} errors, any subsequent will not be printed",
                options.max_errors,
            ))
            .finish()
            .eprint(sources)
            .expect("Failed to print diagnostic");
    }
}

const WARNING_COLOR: Color = Color::Yellow;
pub const WARNING_KIND: ReportKind = ReportKind::Custom("warning", WARNING_COLOR);

// TODO: need also to give me a warning flag!
pub fn warn<F: FnOnce(ReportBuilder) -> ReportBuilder>(
    id: WarningKind,
    span: Span<'_>,
    build: F,
    sources: &SourceStore,
    nb_errors_left: &Cell<usize>,
    options: &Options,
) {
    if options.inhibit_warnings {
        return;
    }

    let kind = match options.warnings[id.0] {
        WarningLevel::Error => ERROR_KIND,
        WarningLevel::Enabled => WARNING_KIND,
        WarningLevel::Default if DEFAULT_WARNINGS[id.0] => WARNING_KIND,
        WarningLevel::Default => return,
        WarningLevel::Disabled => return,
    };
    if kind == ERROR_KIND && nb_errors_left.get() == 0 {
        return;
    }

    let (src_id, byte_range) = span.resolve();
    build(
        Report::build(kind, src_id, byte_range.start)
            .with_config(Config::new().with_index_type(IndexType::Byte))
            .with_code(id),
    )
    .finish()
    .eprint(sources)
    .expect("Failed to print diagnostic");
    if kind == ERROR_KIND {
        decrement_error_count(sources, nb_errors_left, options);
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WarningLevel {
    Disabled,
    Enabled,
    Error,
    Default, // "Meta" warnings will only override this level.
}

// This file is generated by the build script (`build.rs`).
include!(concat!(env!("OUT_DIR"), "/warnings.rs"));

pub fn error_label<S: Into<RawSpan>>(span: S) -> Label<RawSpan> {
    Label::new(span.into()).with_color(ERROR_COLOR)
}

pub fn warning_label<S: Into<RawSpan>>(span: S) -> Label<RawSpan> {
    Label::new(span.into()).with_color(WARNING_COLOR)
}
