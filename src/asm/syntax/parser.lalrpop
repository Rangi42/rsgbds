/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 *
 * SPDX-License-Identifier: MPL-2.0
 */

/*
 * NB: the `ctx.*` functions used throughout this file are defined in the various files in the `semantics` directory.
 */

use compact_str::CompactString;
use either::Either;

use crate::{
	common::section::MemRegion,
	expr::{BinOp, Expr, UnOp},
	instructions::{Condition, Instruction, Reg16Arith, Reg16Mem, Reg16Stack, Reg8},
	macro_args::MacroArgs,
	section::{AssertLevel, SectionAttrs, SectionKind},
	sources::Span,
	Identifier,
};

use super::{ParseCtx, tokens::TokenPayload};

grammar(ctx: &mut ParseCtx<'_, '_, '_, '_, '_, '_>);

// TODO: try to improve syntax error recovery
//       https://lalrpop.github.io/lalrpop/tutorial/008_error_recovery.html


pub Line = DiffMarker? <LineContents> ExtraAtEol?;
LineContents = {
	SpecialDirective, // TODO: accept labels before those, to produce a clearer error message
	LabelDef? <Directive>,
	LabelDef? <Emittable>,
	LabelDef? <MacroCall>,
	LabelDef // LALRPOP doesn't allow productions to match no tokens, so empty lines are simply not passed to the parser.
};
ExtraAtEol: () = ! => { // Necessary so that a syntax error at EOL doesn't cause an immediate abort.
	let should_continue = ctx.report_parse_error(<>.error);
	debug_assert!(should_continue); // Should not have been one of the assertions.
};

DiffMarker: () = {
	// TODO: Git diff markers, too!
	<@L> "+" => ctx.report_diff_marker(<>),
	<@L> "-" => ctx.report_diff_marker(<>),
};

LabelDef: () = {
	// Non-local labels require a colon so that they don't conflict with macro calls.
	<span_idx:@L> <name:LocalIdent> ":"? => ctx.define_label(name, span_idx, false),
	<span_idx:@L> <name:"identifier"> ":" => ctx.define_label(Some(name), span_idx, false),
	<span_idx:@L> <name:Identifier> "::" => ctx.define_label(name, span_idx, true),
	<span_idx:@L> ":" => ctx.define_anon_label(span_idx),
};

// Capturing `Datum` as the "focus" of the repetition makes it return a `Vec<()>`, which does not allocate.
Emittable = <Datum> ("::" <Datum>)*;
Datum: () = {
	Instruction => ctx.emit_instruction(<>),
	// For convenience, these directives are also allowed.
	<span_idx:@L> "ds" <length:Expr>                     => ctx.allocate_space(Either::Left(Either::Left(length)), span_idx),
	<span_idx:@L> "ds" "align" "[" <align:AlignArgs> "]" => ctx.allocate_space(Either::Right(align),               span_idx),
	<span_idx:@L> "db" <bytes:CommaList<StringOrExpr>> => ctx.emit_bytes(bytes, span_idx),
	<span_idx:@L> "dw" <words:CommaList<StringOrExpr>> => ctx.emit_words(words, span_idx),
	<span_idx:@L> "dl" <longs:CommaList<StringOrExpr>> => ctx.emit_longs(longs, span_idx),
	<span_idx:@L> "ds" <length:Expr>                     "," <bytes:CommaList<Expr>> => {
		ctx.emit_padding(Either::Left(Either::Left(length)), bytes, span_idx)
	},
	<span_idx:@L> "ds" "align" "[" <align:AlignArgs> "]" "," <bytes:CommaList<Expr>> => {
		ctx.emit_padding(Either::Right(align),               bytes, span_idx)
	},
};

// LALRPOP doesn't support rules matching 0 tokens, so we have to have `MacroArgs` work around that.
MacroCall: () = <span_idx:@L> <name:"identifier"> <silently:"?"?> <args:MacroArgs?> => {
	ctx.call_macro(name, span_idx, args.unwrap_or_else(MacroArgs::new), silently.is_some());
};
MacroArgs: MacroArgs = {
	@L "string" => { let args = MacroArgs::new(); ctx.push_macro_arg(args, <>) },
	MacroArgs @L "string" => ctx.push_macro_arg(<>)
};

// All of these directives make calls to the lexer to process their “bodies”.
// They are also special to the lexer, since they can introduce levels of nesting;
// therefore, label definitions are not allowed before them.
SpecialDirective: () = {
	"macro" <silently:"?"?> <span_idx:@L> <name:"identifier"> => {
		ctx.capture_macro_def(name, span_idx, silently.is_some())
	},

	<span_idx:@L> "rept" <silently:"?"?> <nb_iters:Expr> => {
		let span = ctx.nth_span(span_idx);
		ctx.capture_loop(None, (None, nb_iters, None), span, silently.is_some())
	},
	<span_idx:@L> "for" <silently:"?"?> <var_span_idx:@L> <var:"identifier"> "," <params:ForParams> => {
		let span = ctx.nth_span(span_idx);
		let var_span = ctx.nth_span(var_span_idx);
		ctx.capture_loop(Some((var, var_span)), params, span, silently.is_some())
	},

	// These are consumed by the capturing functions; so if we see them here, they are not matched by a block opening.
	<span_idx:@L> "endm" => ctx.report_stray(span_idx, "`endm` found outside of a macro"),
	<span_idx:@L> "endr" => ctx.report_stray(span_idx, "`endr` found outside of a loop"),

	<span_idx:@L> "if" <expr:Expr> => ctx.process_if(span_idx, expr),
	// The "end of line" token is injected by the parser's caller if the `elif` was preceded by an executed block,
	// so that its condition is skipped lexically. (See the comment there for an example of why that is useful.)
	<span_idx:@L> "elif" "end of line" => ctx.process_elif(span_idx, None),
	<span_idx:@L> "elif" <expr:Expr>   => ctx.process_elif(span_idx, Some(expr)),
	<span_idx:@L> "else" => ctx.process_else(span_idx),
	<span_idx:@L> "endc" => ctx.process_endc(span_idx),
};
ForParams: (Option<Expr>, Expr, Option<Expr>) = {
	<span_idx:@L>                  <end:Expr>                      => (None, end, None),
	<span_idx:@L> <start:Expr> "," <end:Expr> <step:("," <Expr>)?> => (Some(start), end, step)
};

Directive: () = {
	// `charmap.rs`
	"charmap" <what:StringExpr> "," <mapping:NonEmptyCommaList<ConstExpr>> => ctx.charmap_entry(what, mapping),
	"charmap" <span_idx:@L> <what:"character literal"> "," <mapping:NonEmptyCommaList<ConstExpr>> => {
		let span = ctx.nth_span(span_idx);
		ctx.charmap_entry((what, span), mapping)
	},
	<span_idx:@L> "newcharmap" <name:"identifier"> <src:("," <"identifier">)?> => ctx.create_charmap(name, src, span_idx),
	"setcharmap" <span_idx:@L> <name:"identifier"> => ctx.switch_to_charmap(name, span_idx),
	<span_idx:@L> "pushc" => ctx.push_charmap(),
	<span_idx:@L> "pushc" <name:"identifier"> <src:("," <"identifier">)?> => {
		ctx.push_charmap(); ctx.switch_to_charmap(name, span_idx)
	},
	<span_idx:@L> "popc" => ctx.pop_charmap(span_idx),
	// `context.rs`
	<@L> "break" => ctx.break_loop(<>),
	<span_idx:@L> "include" <silently:"?"?> <path:StringExpr> => {
		ctx.include_file(path, span_idx, silently.is_some())
	},
	// `data.rs`
	// `db`, `dw`, `dl` and `ds` are `Datum`s, instead.
	<span_idx:@L> "incbin" <path:StringExpr> <start:("," <Expr> ","?)?>         => {
		ctx.incbin_file(path, start,       None,         span_idx);
	},
	<span_idx:@L> "incbin" <path:StringExpr> "," <start:Expr> "," <length:Expr> => {
		ctx.incbin_file(path, Some(start), Some(length), span_idx);
	},
	<@L> "union" => ctx.start_union(<>),
	<@L> "nextu" => ctx.union_next(<>),
	<@L> "endu" => ctx.end_union(<>),
	// `macros.rs`
	<span_idx:@L> "shift" <amount:Expr?> => ctx.shift_macro_args(amount, span_idx),
	// `opt.rs`
	"opt" Option+ => (),
	Pusho,
	<span_idx:@L> "popo" => ctx.pop_options(span_idx),
	// `print.rs`
	"print"   CommaList<PrintArg> => (),
	"println" CommaList<PrintArg> => println!(),
	<span_idx:@L> "fail" <msg:StringExpr> =>? ctx.do_fail(msg, span_idx),
	<span_idx:@L> "warn" <msg:StringExpr> => ctx.do_warn(msg, span_idx),
	<span_idx:@L> "assert" <params:AssertParams> =>? ctx.assert(params, span_idx),
	       "static_assert" <params:AssertParams> =>? ctx.static_assert(params),
	// `section.rs`
	<span_idx:@L> "align" <align:AlignArgs> => ctx.align_section(align, span_idx),
	<span_idx:@L> "endl" => ctx.end_load_block(span_idx),
	<span_idx:@L> "endsection" => ctx.end_section(span_idx),
	<span_idx:@L> "load" <attrs:SectionAttrs> => ctx.set_symbol_section(attrs, span_idx),
	<span_idx:@L> "pushs" <attrs:SectionAttrs?> => ctx.push_section(attrs, span_idx),
	<span_idx:@L> "pops" => ctx.pop_section(span_idx),
	<span_idx:@L> "section" <attrs:SectionAttrs> => ctx.create_section(span_idx, attrs),
	// `symbol.rs`
	<export:(<@L> "export")?> <redef:Def> <name:"identifier"> <span_idx:@L> "equs" <value:StringExpr> => {
		ctx.define_string(export, redef, name, value, span_idx)
	},
	<export:(<@L> "export")?> <redef:Def> <name:"identifier"> <span_idx:@L> <mutable:NumDefKeyword> <value:Expr> => {
		ctx.define_numeric(export, redef, name, mutable, value, span_idx)
	},
	<export:(<@L> "export")?> <redef:Def> <name_span_idx:@L> <name:"identifier"> <op_span_idx:@L> <op:CompoundAssignOp> <value:Expr> => {
		ctx.compound_assignment(export, redef, name, op, value, op_span_idx, name_span_idx)
	},
	<export:(<@L> "export")?> <redef:Def> <name:"identifier"> <span_idx:@L> <stride:RsKindKeyword> <value:Expr?> => {
		ctx.define_rs(export, redef, name, stride, value, span_idx)
	},
	<export:(<@L> "export")?> <redef:Def> <span_idx:@L> <name:"identifier"> "(" <params:CommaList<"identifier">> ")" "=" <expr:Expr> => {
		ctx.define_function(redef, name, params, expr, span_idx)
	},
	"export" NonEmptyCommaList<ExportArg> => (),
	"purge" NonEmptyCommaList<PurgeArg> => (),
	"rsreset" => ctx.reset_rs(),
	"rsset" <Expr> => ctx.set_rs(<>),
};
PrintArg: () = StringOrExpr => ctx.print(<>);
Option: () = <span_idx:@L> <string:"string"> => ctx.process_option(&string, span_idx);
Def: bool = { "def" => false, "redef" => true };
NumDefKeyword: bool = { "equ" => false, "=" => true };
ExportArg: () = <span_idx:@L> <name:Identifier> => ctx.export_symbol(name, span_idx);
PurgeArg: () = <span_idx:@L> <name:IdentOrAnon> => ctx.delete_symbol(name, span_idx);

// This is necessary so that the options are pushed before the first `Option` is reduced (and thus options altered).
Pusho: () = {
	"pusho" => ctx.push_options(),
	Pusho <Option>
};

AssertParams: (AssertLevel, Expr, Option<(CompactString, Span)>) = {
	<level:(<AssertLevel> ",")?> <expr:Expr> <msg:("," <StringExpr>)?> => (level.unwrap_or(AssertLevel::Error), expr, msg)
};
AssertLevel: AssertLevel = { "warn" => AssertLevel::Warn, "fail" => AssertLevel::Error, "fatal" => AssertLevel::Fatal };

SectionAttrs: (SectionAttrs, (CompactString, Span)) = {
	<kind:(@L SectionKind)?> <name:StringExpr> "," <mem_region:MemRegion> <addr:("[" <Expr> "]")?> => {
		(ctx.mandatory_section_attrs(kind, mem_region, addr), name)
	},
	<attrs:SectionAttrs> "," <span_idx:@L> "bank"  "[" <bank:Expr>       "]" =>  ctx.set_bank_of(attrs, bank,  span_idx),
	<attrs:SectionAttrs> "," <span_idx:@L> "align" "[" <align:AlignArgs> "]" => ctx.set_align_of(attrs, align, span_idx),
};
SectionKind: SectionKind = { "union" => SectionKind::Union, "fragment" => SectionKind::Fragment };
MemRegion: MemRegion = {
	"rom0"  => MemRegion::Rom0,
	"romx"  => MemRegion::Romx,
	"vram"  => MemRegion::Vram,
	"sram"  => MemRegion::Sram,
	"wram0" => MemRegion::Wram0,
	"wramx" => MemRegion::Wramx,
	"oam"   => MemRegion::Oam,
	"hram"  => MemRegion::Hram,
};
AlignArgs: (u8, u16) = <align:Expr> <ofs:("," <Expr?>)?> => ctx.align_args(align, ofs.flatten());

CompoundAssignOp: BinOp = {
	"+=" => BinOp::Add,
	"-=" => BinOp::Subtract,
	"*=" => BinOp::Multiply,
	"/=" => BinOp::Divide,
	"%=" => BinOp::Modulo,
	"^=" => BinOp::Xor,
	"|=" => BinOp::Or,
	"&=" => BinOp::And,
	"<<=" => BinOp::LeftShift,
	">>=" => BinOp::RightShift,
	">>>=" => BinOp::UnsignedRightShift,
};
RsKindKeyword: i32 = { "rb" => 1, "rw" => 2, "rl" => 4 };

// TODO: accept invalid forms of instructions, to report better error messages for them
//       It would also enable removing the `#[inline]`s on the register productions
Instruction: Option<Instruction> = {
	<l_span_idx:@L> "adc" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::adc(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "add" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::add(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "add" "hl" "," <operand:Reg16Arith> <r_span_idx:@R> => {
		Some(Instruction::add_hl_r16(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "add" "sp" "," <offset:Expr> <r_span_idx:@R> => {
		Some(Instruction::add_sp_imm(offset, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "and" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::and(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "bit" <bit:Expr> "," <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::bit(bit, reg, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	<l_span_idx:@L> "call" <cond:(<InstrCond> ",")?> <addr:Expr> <r_span_idx:@R> => {
		Some(Instruction::call(cond, addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<span_idx:@L> "ccf" => Some(Instruction::ccf(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "cp" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::cp(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "cpl" "a"? <r_span_idx:@R> => Some(Instruction::cpl(ctx.span_from_to(l_span_idx, r_span_idx))),
	<span_idx:@L> "daa" => Some(Instruction::daa(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "dec" <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::dec_r8(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "dec" <reg:Reg16Arith> <r_span_idx:@R> => {
		Some(Instruction::dec_r16(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<span_idx:@L> "di" => Some(Instruction::di(ctx.nth_span(span_idx))),
	<span_idx:@L> "ei" => Some(Instruction::ei(ctx.nth_span(span_idx))),
	<span_idx:@L> "halt" => Some(Instruction::halt(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "inc" <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::inc_r8(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "inc" <reg:Reg16Arith> <r_span_idx:@R> => {
		Some(Instruction::inc_r16(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "jp" <cond:(<InstrCond> ",")?> <addr:Expr> <r_span_idx:@R> => {
		Some(Instruction::jp(cond, addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "jp" "hl" <r_span_idx:@R> => Some(Instruction::jp_hl(ctx.span_from_to(l_span_idx, r_span_idx))),
	<l_span_idx:@L> "jr" <cond:(<InstrCond> ",")?> <addr:Expr> <r_span_idx:@R> => {
		Some(Instruction::jr(cond, addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	// `ld` and `ldh` are at the bottom, since they have so many forms.
	<span_idx:@L> "nop" => Some(Instruction::nop(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "or" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::or(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "pop" <operand:Reg16Stack> <r_span_idx:@R> => {
		Some(Instruction::pop(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "push" <operand:Reg16Stack> <r_span_idx:@R> => {
		Some(Instruction::push(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "res" <bit:Expr> "," <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::res(bit, reg, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	<span_idx:@L> "reti" => Some(Instruction::reti(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "ret" <cond:InstrCond?> <r_span_idx:@R> => {
		Some(Instruction::ret(cond, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<span_idx:@L> "rla" => Some(Instruction::rla(ctx.nth_span(span_idx))),
	<span_idx:@L> "rlca" => Some(Instruction::rlca(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "rlc" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::rlc(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "rl" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::rl(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<span_idx:@L> "rra" => Some(Instruction::rra(ctx.nth_span(span_idx))),
	<span_idx:@L> "rrca" => Some(Instruction::rrca(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "rrc" <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::rrc(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "rr" <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::rr(reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "rst" <addr:Expr> <r_span_idx:@R> => {
		Some(Instruction::rst(addr, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	<l_span_idx:@L> "sbc" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::sbc(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<span_idx:@L> "scf" => Some(Instruction::scf(ctx.nth_span(span_idx))),
	<l_span_idx:@L> "set" <bit:Expr> "," <reg:Reg8> <r_span_idx:@R> => {
		Some(Instruction::set(bit, reg, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	<l_span_idx:@L> "sla" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::sla(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "sra" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::sra(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "srl" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::srl(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "stop" <operand:Expr?> <r_span_idx:@R> => {
		Some(Instruction::stop(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "sub" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::sub(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "swap" <operand:Reg8> <r_span_idx:@R> => {
		Some(Instruction::swap(operand, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "xor" <operands:ArithInstrOperands> <r_span_idx:@R> => {
		Some(Instruction::xor(operands, ctx.span_from_to(l_span_idx, r_span_idx)))
	},

	<l_span_idx:@L> "ldh" RegA "," "[" <addr:Expr> "]" <r_span_idx:@R> => {
		Some(Instruction::ldh(false, addr, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	<l_span_idx:@L> "ldh" "[" <addr:Expr> "]" "," RegA <r_span_idx:@R> => {
		Some(Instruction::ldh(true, addr, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nth_span(l_span_idx)))
	},
	// Need to use `ExprSum` to avoid a reduce/reduce grammar conflict. It should be sufficient for the intended use cases.
	<l_span_idx:@L> LdOrLdh RegA "," "[" <ff00:(<ExprSum<ExprAtom>> "+")?> "c" "]" <r_span_idx:@R> => {
		let _ = ff00.map(|expr| ctx.check_expr_is_ff00(expr));
		Some(Instruction::ldh_c(false, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> LdOrLdh "[" <ff00:(<ExprSum<ExprAtom>> "+")?> "c" "]" "," RegA <r_span_idx:@R> => {
		let _ = ff00.map(|expr| ctx.check_expr_is_ff00(expr));
		Some(Instruction::ldh_c(true, ctx.span_from_to(l_span_idx, r_span_idx)))
	},

	<l_span_idx:@L> "ld" <lhs:Reg8> "," <rhs:Reg8> <r_span_idx:@R> => {
		Instruction::ld_r8_r8(lhs, rhs, ctx.span_from_to(l_span_idx, r_span_idx), ctx.nb_errors_left, ctx.options)
	},
	<l_span_idx:@L> "ld" <reg:Reg8> "," <imm:Expr> <r_span_idx:@R> => {
		Some(Instruction::ld_r8_imm(reg, imm, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" <reg:Reg16Arith> "," <imm:Expr> <r_span_idx:@R> => {
		Some(Instruction::ld_r16_imm(reg, imm, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" RegA "," "[" <reg:Reg16Mem> "]" <r_span_idx:@R> => {
		Some(Instruction::ld_a_r16_ind(false, reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" "[" <reg:Reg16Mem> "]" "," RegA <r_span_idx:@R> => {
		Some(Instruction::ld_a_r16_ind(true, reg, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" RegA "," "[" <addr:Expr> "]" <r_span_idx:@R> => {
		Some(Instruction::ld_a_addr(false, addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" "[" <addr:Expr> "]" "," RegA <r_span_idx:@R> => {
		Some(Instruction::ld_a_addr(true, addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" "sp" "," "hl" <r_span_idx:@R> => {
		Some(Instruction::ld_sp_hl(ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" "hl" "," "sp" <ofs:OfsExpr> <r_span_idx:@R> => {
		Some(Instruction::ld_hl_sp_ofs(ofs, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
	<l_span_idx:@L> "ld" "[" <addr:Expr> "]" "," "sp" <r_span_idx:@R> => {
		Some(Instruction::ld_addr_sp(addr, ctx.span_from_to(l_span_idx, r_span_idx)))
	},
};
#[inline]
LdOrLdh = { "ld", "ldh" };
ArithInstrOperands = (RegA ",")? <Reg8OrImm8>;
Reg8OrImm8: Either<Reg8, Expr> = {
	Reg8 => Either::Left(<>),
	Expr => Either::Right(<>),
};
#[inline]
Reg8: Reg8 = {
	RegB => Reg8::B,
	RegC => Reg8::C,
	RegD => Reg8::D,
	RegE => Reg8::E,
	RegH => Reg8::H,
	RegL => Reg8::L,
	"[" "hl" "]" => Reg8::HlInd,
	RegA => Reg8::A,
};
RegB = { "b", "high" "(" <"bc"> ")" };
RegC = { "c", "low"  "(" <"bc"> ")" };
RegD = { "d", "high" "(" <"de"> ")" };
RegE = { "e", "low"  "(" <"de"> ")" };
RegH = { "h", "high" "(" <"hl"> ")" };
RegL = { "l", "low"  "(" <"hl"> ")" };
RegA = { "a", "high" "(" <"af"> ")" };
#[inline]
Reg16Arith: Reg16Arith = {
	"bc" => Reg16Arith::Bc,
	"de" => Reg16Arith::De,
	"hl" => Reg16Arith::Hl,
	"sp" => Reg16Arith::Sp,
};
#[inline]
Reg16Mem: Reg16Mem = {
	"bc" => Reg16Mem::Bc,
	"de" => Reg16Mem::De,
	"hli" => Reg16Mem::Hli,
	"hl" "+" => Reg16Mem::Hli,
	"hld" => Reg16Mem::Hld,
	"hl" "-" => Reg16Mem::Hld,
};
#[inline]
Reg16Stack: Reg16Stack = {
	"bc" => Reg16Stack::Bc,
	"de" => Reg16Stack::De,
	"hl" => Reg16Stack::Hl,
	"af" => Reg16Stack::Af,
};
InstrCond: Condition = {
	"nz" => Condition::Nz,
	"z" => Condition::Z,
	"nc" => Condition::Nc,
	"c" => Condition::C,
	"!" <InstrCond> => <>.negate(),
};

// Since a top-level identifier can be either a string or an expression, it must be handled specially.
StringOrExpr: Either<Expr, (CompactString, Span)> = {
	ExprLogicOr<ExprAtomNoIdent> => Either::Left(<>),
	StringExprNoIdent => Either::Right(<>),
	<span_idx:@L> <ident:"identifier"> => ctx.string_or_numeric_sym(ident, span_idx),
};

// Try to avoid using this, as the default value upon error may cause spurious errors to be reported.
// Currently only used to avoid a `Vec<Expr>`.
ConstExpr: i32 = Expr => match ctx.try_const_eval(&<>) {
	Ok((value, _span)) => value,
	Err(err) => {
		ctx.report_expr_error(err);
		0
	}
};

OfsExpr: Expr = {
	<span_idx:@L> "+" <expr:Expr> => expr.unary_op(UnOp::Identity,   ctx.nth_span(span_idx)),
	<span_idx:@L> "-" <expr:Expr> => expr.unary_op(UnOp::Negation,   ctx.nth_span(span_idx)),
};

// Places that don't handle strings and expressions together can use `Expr` directly.
Expr = ExprLogicOr<ExprAtom>;
// The point of all of these productions being macros is to pass `Atom` as the expression's LHS all the way to `ExprExponent`,
// so that leading identifiers can be excluded when they would be ambiguous with string expressions.
// Note that they are only excluded when not part of an expression, since e.g. `this + that` is unambiguously a numeric expression,
// and `this ++ that` is unambiguously a string expression.
// (This does mean that the set of infix operators used for each expression kind must be distinct, but that's fine.)
//
// A note about associativity and precedence:
//     LALRPOP, unlike Bison/YACC, does not support specifying associativity or precedence [1, 2], so it must be encoded manually.
//     Please see [1] for an explanation; the gist of it is that each nonterminal corresponds to one precedence level,
//     and associativity is encoded by which operand refers to the same nonterminal, and which one refers to the “inner” one.
// [1]: https://lalrpop.github.io/lalrpop/tutorial/004_full_expressions.html
// [2]: https://www.gnu.org/software/bison/manual/bison.html#Precedence
ExprLogicOr<Atom>: Expr = {
	<lhs:ExprLogicOr<ExprAtom>> <span_idx:@L> "||" <rhs:ExprLogicAnd<ExprAtom>> => lhs.binary_op(BinOp::LogicalOr, rhs, ctx.nth_span(span_idx)),
	ExprLogicAnd<Atom>
};
ExprLogicAnd<Atom>: Expr = {
	<lhs:ExprLogicAnd<ExprAtom>> <span_idx:@L> "&&" <rhs:ExprComparison<ExprAtom>> => lhs.binary_op(BinOp::LogicalAnd, rhs, ctx.nth_span(span_idx)),
	ExprComparison<Atom>
};
ExprComparison<Atom>: Expr = {
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> "!=" <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::NotEqual,  rhs, ctx.nth_span(span_idx)),
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> "==" <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::Equal,     rhs, ctx.nth_span(span_idx)),
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> "<=" <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::LessEq,    rhs, ctx.nth_span(span_idx)),
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> "<"  <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::Less,      rhs, ctx.nth_span(span_idx)),
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> ">=" <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::GreaterEq, rhs, ctx.nth_span(span_idx)),
	<lhs:ExprComparison<ExprAtom>> <span_idx:@L> ">"  <rhs:ExprSum<ExprAtom>> => lhs.binary_op(BinOp::Greater,   rhs, ctx.nth_span(span_idx)),
	ExprSum<Atom>
};
ExprSum<Atom>: Expr = {
	<lhs:ExprSum<ExprAtom>> <span_idx:@L> "+" <rhs:ExprBitOp<ExprAtom>> => lhs.binary_op(BinOp::Add,      rhs, ctx.nth_span(span_idx)),
	<lhs:ExprSum<ExprAtom>> <span_idx:@L> "-" <rhs:ExprBitOp<ExprAtom>> => lhs.binary_op(BinOp::Subtract, rhs, ctx.nth_span(span_idx)),
	ExprBitOp<Atom>
};
ExprBitOp<Atom>: Expr = {
	<lhs:ExprBitOp<ExprAtom>> <span_idx:@L> "&" <rhs:ExprShift<ExprAtom>> => lhs.binary_op(BinOp::And, rhs, ctx.nth_span(span_idx)),
	<lhs:ExprBitOp<ExprAtom>> <span_idx:@L> "|" <rhs:ExprShift<ExprAtom>> => lhs.binary_op(BinOp::Or,  rhs, ctx.nth_span(span_idx)),
	<lhs:ExprBitOp<ExprAtom>> <span_idx:@L> "^" <rhs:ExprShift<ExprAtom>> => lhs.binary_op(BinOp::Xor, rhs, ctx.nth_span(span_idx)),
	ExprShift<Atom>
};
ExprShift<Atom>: Expr = {
	<lhs:ExprShift<ExprAtom>> <span_idx:@L> "<<"  <rhs:ExprFactor<ExprAtom>> => lhs.binary_op(BinOp::LeftShift,          rhs, ctx.nth_span(span_idx)),
	<lhs:ExprShift<ExprAtom>> <span_idx:@L> ">>"  <rhs:ExprFactor<ExprAtom>> => lhs.binary_op(BinOp::RightShift,         rhs, ctx.nth_span(span_idx)),
	<lhs:ExprShift<ExprAtom>> <span_idx:@L> ">>>" <rhs:ExprFactor<ExprAtom>> => lhs.binary_op(BinOp::UnsignedRightShift, rhs, ctx.nth_span(span_idx)),
	ExprFactor<Atom>
};
ExprFactor<Atom>: Expr = {
	<lhs:ExprFactor<ExprAtom>> <span_idx:@L> "*" <rhs:ExprUnary<ExprAtom>> => lhs.binary_op(BinOp::Multiply, rhs, ctx.nth_span(span_idx)),
	<lhs:ExprFactor<ExprAtom>> <span_idx:@L> "/" <rhs:ExprUnary<ExprAtom>> => lhs.binary_op(BinOp::Divide,   rhs, ctx.nth_span(span_idx)),
	<lhs:ExprFactor<ExprAtom>> <span_idx:@L> "%" <rhs:ExprUnary<ExprAtom>> => lhs.binary_op(BinOp::Modulo,   rhs, ctx.nth_span(span_idx)),
	ExprUnary<Atom>
};
ExprUnary<Atom>: Expr = {
	<span_idx:@L> "~" <expr:ExprUnary<ExprAtom>> => expr.unary_op(UnOp::Complement, ctx.nth_span(span_idx)),
	<span_idx:@L> "+" <expr:ExprUnary<ExprAtom>> => expr.unary_op(UnOp::Identity,   ctx.nth_span(span_idx)),
	<span_idx:@L> "-" <expr:ExprUnary<ExprAtom>> => expr.unary_op(UnOp::Negation,   ctx.nth_span(span_idx)),
	<span_idx:@L> "!" <expr:ExprUnary<ExprAtom>> => expr.unary_op(UnOp::Not,        ctx.nth_span(span_idx)),
	ExprExponent<Atom>
};
ExprExponent<Atom>: Expr = { // Note the reversed expression tokens, which make `**` right-associative.
	<lhs:ExprAtom> <span_idx:@L> "**" <rhs:ExprUnary<ExprAtom>> => lhs.binary_op(BinOp::Exponent, rhs, ctx.nth_span(span_idx)),
	Atom
};
ExprAtom: Expr = {
	<span_idx:@L> <ident:"identifier"> => ctx.ident(ident, span_idx),
	<StringExprNoIdent> => ctx.str_to_num(<>),
	ExprAtomNoIdent
};
ExprAtomNoIdent: Expr = {
	"(" <Expr> ")",
	<span_idx:@L> <ident:LocalIdent> => ctx.local_ident(ident, span_idx),
	<span_idx:@L> <ident:AnonLabelRef> => ctx.anon_label_ref(ident, span_idx),
	<span_idx:@L> <number:"number"> => Expr::number(number as i32, ctx.line_spans[span_idx].clone()),
	<span_idx:@L> <ch:"character literal"> => ctx.convert_char_lit(ch, span_idx),
	<l_span_idx:@L> <func:"identifier"> <lazy_eval:(<@L> "!")?> "(" <args:CommaList<Expr>> ")" <r_span_idx:@R> => {
		ctx.function_call(func, lazy_eval, args, l_span_idx, r_span_idx)
	},
	// TODO: `OPCODE`
	// Arithmetic functions.
	<l_span_idx:@L> "high" "(" <expr:Expr> ")" <r_span_idx:@R> => expr.high(ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "low"  "(" <expr:Expr> ")" <r_span_idx:@R> => expr.low(ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "bitwidth" "(" <expr:Expr> ")" <r_span_idx:@R> => expr.bitwidth(ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "tzcount"  "(" <expr:Expr> ")" <r_span_idx:@R> => expr.tzcount(ctx.span_from_to(l_span_idx, r_span_idx)),
	// Symbol and section functions.
	<l_span_idx:@L> "isconst" "(" <expr:Expr> ")" <r_span_idx:@R> => ctx.is_expr_constant(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "def" "(" <ident:IdentOrAnon> ")" <r_span_idx:@R> => ctx.expr_def_of_symbol(ident, l_span_idx, r_span_idx),
	<l_span_idx:@L> "bank" "(" <ident:(@L IdentOrAnon)>  ")" <r_span_idx:@R> => ctx.bank_of_ident(ident, l_span_idx, r_span_idx),
	<l_span_idx:@L> "bank" "(" <sect:StringExprNoIdent> ")" <r_span_idx:@R> => Expr::bank_of_section(sect.0, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" <sect:StringExpr>  ")" <r_span_idx:@R> => Expr::size_of_section(sect.0, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" <region:MemRegion> ")" <r_span_idx:@R> =>  Expr::size_of_region(region, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "startof" "(" <sect:StringExpr>  ")" <r_span_idx:@R> => Expr::start_of_section(sect.0, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "startof" "(" <region:MemRegion> ")" <r_span_idx:@R> =>  Expr::start_of_region(region, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" Reg8             ")" <r_span_idx:@R> => Expr::number(1, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" "[" Reg16Mem "]" ")" <r_span_idx:@R> => Expr::number(1, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" Reg16Arith       ")" <r_span_idx:@R> => Expr::number(2, ctx.span_from_to(l_span_idx, r_span_idx)),
	<l_span_idx:@L> "sizeof" "(" "af"             ")" <r_span_idx:@R> => Expr::number(2, ctx.span_from_to(l_span_idx, r_span_idx)),
	// Fixed-point functions.
	<l_span_idx:@L> "round" "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_round(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "ceil"  "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> =>  ctx.fixpoint_ceil(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "floor" "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_floor(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "div" "("  <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_div(lhs, rhs, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "mul" "("  <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_mul(lhs, rhs, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "fmod" "(" <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_mod(lhs, rhs, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "pow" "("  <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_pow(lhs, rhs, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "log" "("  <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_log(lhs, rhs, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "sin" "("  <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> =>  ctx.fixpoint_sin(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "cos" "("  <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> =>  ctx.fixpoint_cos(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "tan" "("  <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> =>  ctx.fixpoint_tan(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "asin" "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_asin(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "acos" "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_acos(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "atan" "(" <expr:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_atan(expr, prec, l_span_idx, r_span_idx),
	<l_span_idx:@L> "atan2" "(" <lhs:Expr> "," <rhs:Expr> <prec:("," <Expr>)?> ")" <r_span_idx:@R> => ctx.fixpoint_atan2(lhs, rhs, prec, l_span_idx, r_span_idx),
	// String functions.
	<l_span_idx:@L> "strcmp"    "(" <lhs:StringExpr> "," <rhs:StringExpr> ")" <r_span_idx:@R> =>   ctx.strcmp(lhs, rhs, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strfind"   "(" <lhs:StringExpr> "," <rhs:StringExpr> ")" <r_span_idx:@R> =>  ctx.strfind(lhs, rhs, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strrfind"  "(" <lhs:StringExpr> "," <rhs:StringExpr> ")" <r_span_idx:@R> => ctx.strrfind(lhs, rhs, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strlen"    "(" <expr:StringExpr> ")" <r_span_idx:@R> =>    ctx.strlen(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "bytelen"   "(" <expr:StringExpr> ")" <r_span_idx:@R> =>   ctx.bytelen(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "charlen"   "(" <expr:StringExpr> ")" <r_span_idx:@R> =>   ctx.charlen(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "incharmap" "(" <expr:StringExpr> ")" <r_span_idx:@R> => ctx.incharmap(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "charcmp"   "(" <lhs:StringExpr> "," <rhs:StringExpr> ")" <r_span_idx:@R> => ctx.charcmp(lhs, rhs, l_span_idx, r_span_idx),
	<l_span_idx:@L> "charsize"  "(" <expr:StringExpr> ")" <r_span_idx:@R> => ctx.charsize(expr, l_span_idx, r_span_idx),
	<l_span_idx:@L> "charval"   "(" <string:StringExpr> ")" <r_span_idx:@R> => ctx.charval_single(string, l_span_idx, r_span_idx),
	<l_span_idx:@L> "charval"   "(" <string:StringExpr> "," <pos:Expr> ")" <r_span_idx:@R> => ctx.charval(string, pos, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strbyte"   "(" <string:StringExpr> "," <pos:Expr> ")" <r_span_idx:@R> => ctx.strbyte(string, pos, l_span_idx, r_span_idx),
	<lhs:StringExpr> "===" <rhs:StringExpr> => ctx.string_equal(lhs, rhs),
	<lhs:StringExpr> "!==" <rhs:StringExpr> => ctx.string_unequal(lhs, rhs),
};

StringExpr = StringExprConcat<StringExprAtom>;
StringExprNoIdent = StringExprConcat<StringExprAtomNoIdent>;
StringExprConcat<Atom>: (CompactString, Span) = {
	<lhs:StringExprConcat<StringExprAtom>> "++" <rhs:StringExprAtom> => (lhs.0 + &rhs.0, lhs.1.merged_with(&rhs.1)),
	<Atom>,
};
StringExprAtom: (CompactString, Span) = {
	<span_idx:@L> <ident:"identifier"> => ctx.string_symbol(ident, span_idx),
	StringExprAtomNoIdent
};
StringExprAtomNoIdent: (CompactString, Span) = {
	// FIXME: should be able to become `nth_span` when strings-as-nums are removed
	<span_idx:@L> <string:"string"> => (string, ctx.line_spans[span_idx].clone()),
	// TODO: readfile
	<l_span_idx:@L> "strslice" "(" <string:StringExpr> "," <start:Expr> <end:("," <Expr>)?> ")" <r_span_idx:@R> => {
		ctx.strslice(string, start, end, l_span_idx, r_span_idx)
	},
	<l_span_idx:@L> "strchar" "(" <string:StringExpr> "," <idx:Expr> ")" <r_span_idx:@R> => ctx.strchar(string, idx, l_span_idx, r_span_idx),
	<l_span_idx:@L> "revchar" "(" <mapping:NonEmptyCommaList<ConstExpr>> ")" <r_span_idx:@R> => {
		ctx.revchar(mapping, l_span_idx, r_span_idx)
	},
	<l_span_idx:@L> "strcat" "(" <string:(<StrcatArgs> ","?)?> ")" <r_span_idx:@R> => {
		(string.unwrap_or_default(), ctx.span_from_to(l_span_idx, r_span_idx))
	},
	<l_span_idx:@L> "strupr" "(" <string:StringExpr> ")" <r_span_idx:@R> => ctx.strupr(string, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strlwr" "(" <string:StringExpr> ")" <r_span_idx:@R> => ctx.strlwr(string, l_span_idx, r_span_idx),
	<l_span_idx:@L> "strrpl" "(" <haystack:StringExpr> "," <needle:StringExpr> "," <replacement:StringExpr> ")" <r_span_idx:@R> => {
		ctx.strrpl(haystack, needle, replacement, l_span_idx, r_span_idx)
	},
	<l_span_idx:@L> "strfmt" "(" <fmt:StringExpr> <args:("," <CommaList<StringOrExpr>>)?> ")" <r_span_idx:@R> => {
		ctx.strfmt(fmt, args.unwrap_or_default(), l_span_idx, r_span_idx)
	},
	<l_span_idx:@L> "section" "(" <span_idx: @L> <sym:IdentOrAnon> ")" <r_span_idx:@R> => {
		ctx.section_of((sym, &ctx.line_spans[span_idx]), l_span_idx, r_span_idx)
	},
};
StrcatArgs: CompactString = {
	<StringExpr> => <>.0,
	<acc:StrcatArgs> "," <string:StringExpr> => acc + &string.0
};

Identifier: Option<Identifier> = {
	"identifier" => Some(<>),
	<LocalIdent>,
};
LocalIdent: Option<Identifier> = {
	"scoped identifier" => Some(<>),
	<span_idx:@L> <ident:"local identifier"> => ctx.resolve_local_ident(ident, span_idx),
};
AnonLabelRef: Option<Identifier> = {
	<span_idx:@L> <offset:"anonymous label reference"> => ctx.anon_label_name(offset, span_idx)
};
IdentOrAnon = { <Identifier>, <AnonLabelRef> };

// A list of comma-separated elements, optionally with a trailing comma.
CommaList<T>: Vec<T> = <mut list:(<T> ",")*> <last:T?> => match last {
	None => list,
	Some(elem) => {
		list.push(elem);
		list
	}
};
NonEmptyCommaList<T>: Vec<T> = <mut list:(<T> ",")*> <last:T> ","? => {
	list.push(last);
	list
};


// Lexer interface.
extern {
	type Location = usize; // Really, indices into `ctx.line_spans`.
	type Error = ();

	enum TokenPayload {
		"end of line" => TokenPayload::Newline,

		"number" => TokenPayload::Number(<u32>),
		"string" => TokenPayload::String(<CompactString>),
		"character literal" => TokenPayload::CharLit(<CompactString>),
		"identifier" => TokenPayload::Identifier(<Identifier>),
		"scoped identifier" => TokenPayload::ScopedIdentifier(<Identifier>),
		"local identifier" => TokenPayload::LocalIdentifier(<CompactString>),
		"anonymous label reference" => TokenPayload::AnonLabelRef(<i32>),

		"," => TokenPayload::Comma,
		":" => TokenPayload::Colon,
		"::" => TokenPayload::DblColon,
		"[" => TokenPayload::LBrack,
		"]" => TokenPayload::RBrack,
		"(" => TokenPayload::LParen,
		")" => TokenPayload::RParen,
		"+" => TokenPayload::Plus,
		"-" => TokenPayload::Minus,
		"*" => TokenPayload::Asterisk,
		"/" => TokenPayload::Slash,
		"%" => TokenPayload::Percent,
		"++" => TokenPayload::DblPlus,
		"**" => TokenPayload::DblAsterisk,
		"==" => TokenPayload::DblEqual,
		"!=" => TokenPayload::NotEqu,
		"===" => TokenPayload::TripleEqual,
		"!==" => TokenPayload::NotEquEqu,
		"<" => TokenPayload::Lt,
		">" => TokenPayload::Gt,
		"<=" => TokenPayload::Lte,
		">=" => TokenPayload::Gte,
		"&&" => TokenPayload::DblAmpersand,
		"||" => TokenPayload::DlbPipe,
		"!" => TokenPayload::Bang,
		"?" => TokenPayload::Question,
		"&" => TokenPayload::Ampersand,
		"|" => TokenPayload::Pipe,
		"^" => TokenPayload::Caret,
		"<<" => TokenPayload::Shl,
		">>" => TokenPayload::Shr,
		">>>" => TokenPayload::UShr,
		"~" => TokenPayload::Complement,
		"=" => TokenPayload::Equal,
		"+=" => TokenPayload::AddEq,
		"-=" => TokenPayload::SubEq,
		"*=" => TokenPayload::MulEq,
		"/=" => TokenPayload::DivEq,
		"%=" => TokenPayload::ModEq,
		"&=" => TokenPayload::BitAndEq,
		"|=" => TokenPayload::BitOrEq,
		"^=" => TokenPayload::BitXorEq,
		"<<=" => TokenPayload::ShlEq,
		">>=" => TokenPayload::ShrEq,
		">>>=" => TokenPayload::UShrEq,

		"b" => TokenPayload::B,
		"c" => TokenPayload::C,
		"d" => TokenPayload::D,
		"e" => TokenPayload::E,
		"h" => TokenPayload::H,
		"l" => TokenPayload::L,
		"a" => TokenPayload::A,
		"af" => TokenPayload::Af,
		"bc" => TokenPayload::Bc,
		"de" => TokenPayload::De,
		"hl" => TokenPayload::Hl,
		"sp" => TokenPayload::Sp,
		"hli" => TokenPayload::HlInc,
		"hld" => TokenPayload::HlDec,

		"z" => TokenPayload::Z,
		"nz" => TokenPayload::Nz,
		"nc" => TokenPayload::Nc,

		"adc" => TokenPayload::Adc,
		"add" => TokenPayload::Add,
		"and" => TokenPayload::And,
		"bit" => TokenPayload::Bit,
		"call" => TokenPayload::Call,
		"ccf" => TokenPayload::Ccf,
		"cp" => TokenPayload::Cp,
		"cpl" => TokenPayload::Cpl,
		"daa" => TokenPayload::Daa,
		"dec" => TokenPayload::Dec,
		"di" => TokenPayload::Di,
		"ei" => TokenPayload::Ei,
		"halt" => TokenPayload::Halt,
		"inc" => TokenPayload::Inc,
		"jp" => TokenPayload::Jp,
		"jr" => TokenPayload::Jr,
		"ldh" => TokenPayload::Ldh,
		"ld" => TokenPayload::Ld,
		"nop" => TokenPayload::Nop,
		"or" => TokenPayload::Or,
		"pop" => TokenPayload::Pop,
		"push" => TokenPayload::Push,
		"res" => TokenPayload::Res,
		"reti" => TokenPayload::Reti,
		"ret" => TokenPayload::Ret,
		"rla" => TokenPayload::Rla,
		"rlca" => TokenPayload::Rlca,
		"rlc" => TokenPayload::Rlc,
		"rl" => TokenPayload::Rl,
		"rra" => TokenPayload::Rra,
		"rrca" => TokenPayload::Rrca,
		"rrc" => TokenPayload::Rrc,
		"rr" => TokenPayload::Rr,
		"rst" => TokenPayload::Rst,
		"sbc" => TokenPayload::Sbc,
		"scf" => TokenPayload::Scf,
		"set" => TokenPayload::Set,
		"sla" => TokenPayload::Sla,
		"sra" => TokenPayload::Sra,
		"srl" => TokenPayload::Srl,
		"stop" => TokenPayload::Stop,
		"sub" => TokenPayload::Sub,
		"swap" => TokenPayload::Swap,
		"xor" => TokenPayload::Xor,

		"align" => TokenPayload::Align,
		"assert" => TokenPayload::Assert,
		"break" => TokenPayload::Break,
		"charmap" => TokenPayload::Charmap,
		"db" => TokenPayload::Db,
		"dl" => TokenPayload::Dl,
		"ds" => TokenPayload::Ds,
		"dw" => TokenPayload::Dw,
		"elif" => TokenPayload::Elif,
		"else" => TokenPayload::Else,
		"endc" => TokenPayload::Endc,
		"endl" => TokenPayload::Endl,
		"endm" => TokenPayload::Endm,
		"endr" => TokenPayload::Endr,
		"endsection" => TokenPayload::Endsection,
		"endu" => TokenPayload::Endu,
		"equ" => TokenPayload::Equ,
		"equs" => TokenPayload::Equs,
		"export" => TokenPayload::Export,
		"fail" => TokenPayload::Fail,
		"fatal" => TokenPayload::Fatal,
		"for" => TokenPayload::For,
		"fragment" => TokenPayload::Fragment,
		"if" => TokenPayload::If,
		"incbin" => TokenPayload::Incbin,
		"include" => TokenPayload::Include,
		"load" => TokenPayload::Load,
		"macro" => TokenPayload::Macro,
		"newcharmap" => TokenPayload::Newcharmap,
		"nextu" => TokenPayload::Nextu,
		"opt" => TokenPayload::Opt,
		"popc" => TokenPayload::Popc,
		"popo" => TokenPayload::Popo,
		"pops" => TokenPayload::Pops,
		"println" => TokenPayload::Println,
		"print" => TokenPayload::Print,
		"purge" => TokenPayload::Purge,
		"pushc" => TokenPayload::Pushc,
		"pusho" => TokenPayload::Pusho,
		"pushs" => TokenPayload::Pushs,
		"rb" => TokenPayload::Rb,
		"redef" => TokenPayload::Redef,
		"rept" => TokenPayload::Rept,
		"rsreset" => TokenPayload::Rsreset,
		"rsset" => TokenPayload::Rsset,
		"rw" => TokenPayload::Rw,
		"section" => TokenPayload::Section,
		"setcharmap" => TokenPayload::Setcharmap,
		"shift" => TokenPayload::Shift,
		"static_assert" => TokenPayload::StaticAssert,
		"union" => TokenPayload::Union,
		"warn" => TokenPayload::Warn,

		"acos" => TokenPayload::Acos,
		"asin" => TokenPayload::Asin,
		"atan" => TokenPayload::Atan,
		"atan2" => TokenPayload::Atan2,
		"bank" => TokenPayload::Bank,
		"bitwidth" => TokenPayload::Bitwidth,
		"bytelen" => TokenPayload::Bytelen,
		"ceil" => TokenPayload::Ceil,
		"charcmp" => TokenPayload::Charcmp,
		"charlen" => TokenPayload::Charlen,
		"charsize" => TokenPayload::Charsize,
		"charsub" => TokenPayload::Charsub,
		"charval" => TokenPayload::Charval,
		"cos" => TokenPayload::Cos,
		"def" => TokenPayload::Def,
		"div" => TokenPayload::Div,
		"floor" => TokenPayload::Floor,
		"fmod" => TokenPayload::Fmod,
		"mul" => TokenPayload::Mul,
		"high" => TokenPayload::High,
		"incharmap" => TokenPayload::Incharmap,
		"isconst" => TokenPayload::Isconst,
		"log" => TokenPayload::Log,
		"low" => TokenPayload::Low,
		"pow" => TokenPayload::Pow,
		"readfile" => TokenPayload::Readfile,
		"revchar" => TokenPayload::Revchar,
		"round" => TokenPayload::Round,
		"sin" => TokenPayload::Sin,
		"sizeof" => TokenPayload::Sizeof,
		"startof" => TokenPayload::Startof,
		"strbyte" => TokenPayload::Strbyte,
		"strcat" => TokenPayload::Strcat,
		"strchar" => TokenPayload::Strchar,
		"strcmp" => TokenPayload::Strcmp,
		"strfind" => TokenPayload::Strfind,
		"strfmt" => TokenPayload::Strfmt,
		"strlen" => TokenPayload::Strlen,
		"strlwr" => TokenPayload::Strlwr,
		"strrfind" => TokenPayload::Strrfind,
		"strrpl" => TokenPayload::Strrpl,
		"strslice" => TokenPayload::Strslice,
		"strsub" => TokenPayload::Strsub,
		"strupr" => TokenPayload::Strupr,
		"tan" => TokenPayload::Tan,
		"tzcount" => TokenPayload::Tzcount,

		"hram" => TokenPayload::Hram,
		"oam" => TokenPayload::Oam,
		"rom0" => TokenPayload::Rom0,
		"romx" => TokenPayload::Romx,
		"sram" => TokenPayload::Sram,
		"vram" => TokenPayload::Vram,
		"wram0" => TokenPayload::Wram0,
		"wramx" => TokenPayload::Wramx,
	}
}
