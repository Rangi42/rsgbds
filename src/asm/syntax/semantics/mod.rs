use std::fmt::Display;

use crate::{
    common::S,
    diagnostics::{self, ReportBuilder, WarningKind},
    expr::Expr,
    sources::Span,
};

use super::{parse_ctx, tokens::TokenPayload};

mod charmap;
mod condition;
mod context;
mod data;
mod error;
mod expr;
pub mod fixed_point; // Exporting the fixed-point precision clamp function for the lexer.
mod instructions;
mod macros;
mod opt;
mod print;
mod section;
mod string;
mod symbols;

type ParseError = lalrpop_util::ParseError<usize, TokenPayload, ()>;

/// Utilities used pervasively throughout semantic actions.
impl parse_ctx!() {
    pub(super) fn nth_span(&mut self, span_idx: usize) -> Span {
        // Use a value that isn't supposed to appear at all,
        // so that a double call to this function fails in a conspicuous way even in release mode.
        let span = std::mem::replace(&mut self.line_spans[span_idx], Span::CommandLine);
        debug_assert!(
            matches!(span, Span::Normal(_)),
            "`nth_span` called twice on idx {span_idx}"
        );
        span
    }

    pub(super) fn span_from_to_maybe_eq(&self, left_idx: usize, right_idx: usize) -> Span {
        if left_idx == right_idx {
            self.line_spans[left_idx].clone()
        } else {
            self.span_from_to(left_idx, right_idx)
        }
    }

    pub(super) fn span_from_to(&self, left_idx: usize, right_idx: usize) -> Span {
        debug_assert_ne!(left_idx, right_idx);
        self.line_spans[left_idx].merged_with(&self.line_spans[right_idx])
    }

    pub(super) fn try_const_eval(&self, expr: &Expr) -> Result<(i32, Span), crate::expr::Error> {
        expr.try_const_eval(
            self.symbols,
            self.macro_args.last(),
            self.sections,
            |warning, span| warning.report(span, self.nb_errors_left, self.options),
        )
    }

    pub(super) fn error<'span, F: FnOnce(&mut ReportBuilder<'span>)>(
        &self,
        span: &'span Span,
        callback: F,
    ) {
        diagnostics::error(span, callback, self.nb_errors_left, self.options);
    }
    pub(super) fn report_expr_error(&self, error: crate::expr::Error) {
        error.report(self.identifiers, self.nb_errors_left, self.options);
    }

    pub(super) fn warn<'span, F: FnOnce(&mut ReportBuilder<'span>)>(
        &self,
        id: WarningKind,
        span: &'span Span,
        callback: F,
    ) {
        diagnostics::warn(id, span, callback, self.nb_errors_left, self.options);
    }

    pub(super) fn report_parse_error(&self, err: ParseError) -> bool {
        struct ExpectedTokens(Vec<String>);
        impl Display for ExpectedTokens {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                const MAX_TOKENS_LISTED: usize = 7;
                match self.0.as_slice() {
                    [] => write!(f, "nothing else on this line"),
                    [only] => write!(f, "{only}"),
                    expected if expected.len() > MAX_TOKENS_LISTED => {
                        for name in &expected[..MAX_TOKENS_LISTED] {
                            write!(f, "{name}, ")?;
                        }
                        let nb_truncated = expected.len() - MAX_TOKENS_LISTED;
                        write!(f, "...{nb_truncated} other{}", S::from(nb_truncated))
                    }
                    [expected @ .., last] => {
                        for name in expected {
                            write!(f, "{name}, ")?;
                        }
                        write!(f, "or {last}")
                    }
                }
            }
        }

        match err {
            // This is generated by the built-in lexer, but we don't use it.
            ParseError::InvalidToken { .. } => unreachable!(),

            ParseError::UnrecognizedEof { location, expected } => {
                let span = &self.line_spans[location];
                self.error(span, |error| {
                    error.set_message("syntax error: unexpected end of line");
                    error.add_label(
                        diagnostics::error_label(span)
                            .with_message(format!("expected {}", ExpectedTokens(expected))),
                    );
                });
                true
            }
            ParseError::UnrecognizedToken {
                token: (span_idx, token, _span_idx),
                expected,
            } => {
                let span = &self.line_spans[span_idx];
                self.error(span, |error| {
                    error.set_message(format!("syntax error: unexpected {token}"));
                    error.add_label(
                        diagnostics::error_label(span)
                            .with_message(format!("expected {}", ExpectedTokens(expected))),
                    );
                });
                true
            }
            ParseError::ExtraToken {
                token: (span_idx, token, _span_idx),
            } => {
                let span = &self.line_spans[span_idx];
                self.error(span, |error| {
                    error.set_message(format!("syntax error: unexpected {token}"));
                    error.add_label(
                        diagnostics::error_label(span)
                            .with_message("expected nothing else on this line"),
                    );
                });
                true
            }
            // We use this to signal fatal errors.
            ParseError::User { error: () } => false,
        }
    }
}
